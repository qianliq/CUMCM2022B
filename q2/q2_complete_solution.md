# é”¥å½¢ç¼–é˜Ÿä¼˜åŒ–ç®—æ³• - å®Œæ•´è§£å†³æ–¹æ¡ˆ

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

åŸºäºMATLABä»£ç çš„Pythonå®ç°ï¼Œè§£å†³é”¥å½¢ç¼–é˜Ÿä¸­æ— äººæœºä½ç½®ä¼˜åŒ–é—®é¢˜ã€‚é€šè¿‡é€‰æ‹©æœ€ä¼˜çš„ä¸‰æœºå‚è€ƒç»„åˆï¼Œä½¿ç”¨å‡ ä½•çº¦æŸå’Œè§’åº¦åŒ¹é…åŸç†ï¼Œè¿­ä»£ä¼˜åŒ–æ‰€æœ‰é£æœºä½ç½®ï¼Œä½¿å…¶å°½å¯èƒ½æ¥è¿‘ç†æƒ³ç¼–é˜Ÿã€‚

## ğŸ“ æ–‡ä»¶ç»“æ„

```
q4_cone_formation_python.py    # å®Œæ•´ç‰ˆæœ¬å®ç°
q4_simplified_algorithm.py     # ç®€åŒ–ç‰ˆæœ¬ï¼ˆæ•™å­¦ç”¨ï¼‰
q4_helper_functions.py         # è¾…åŠ©å‡½æ•°é›†åˆ
q4_algorithm_explanation.md    # è¯¦ç»†ç®—æ³•æ€è·¯è§£é‡Š
```

## ğŸ¯ æ ¸å¿ƒé—®é¢˜

### é—®é¢˜æè¿°
- **ç¼–é˜Ÿç»“æ„**: 15æ¶æ— äººæœºç»„æˆé”¥å½¢ç¼–é˜Ÿ
- **çº¦æŸæ¡ä»¶**: æ¯æ¬¡åªèƒ½é€‰æ‹©3æ¶é£æœºä½œä¸ºå‚è€ƒåŸºå‡†
- **ä¼˜åŒ–ç›®æ ‡**: æœ€å°åŒ–æ‰€æœ‰é£æœºåˆ°ç†æƒ³ä½ç½®çš„æ€»è·ç¦»è¯¯å·®
- **æŒ‘æˆ˜**: åœ¨å­˜åœ¨ä½ç½®åå·®çš„æƒ…å†µä¸‹æ‰¾åˆ°æœ€ä¼˜è°ƒåº¦ç­–ç•¥

### ç¼–é˜Ÿå‡ ä½•ç»“æ„
```
       11(0,4)
    7(1,3) 12(0,2) 10(1,-3)
   4(2,2) 5(2,0) 6(2,-2)
  2(3,1) 13(0,0) 3(3,-1)
       1(4,0)
  8(1,1) 14(0,-2) 9(1,-1)
       15(0,-4)
```

## ğŸ”§ ç®—æ³•æ ¸å¿ƒæ€è·¯

### 1. ä¸‰è§’å®šä½åŸç†
```
å¯¹äºéœ€è¦è°ƒæ•´çš„é£æœºMï¼š
1. é€‰æ‹©ä¸‰ä¸ªå‚è€ƒç‚¹Aã€Bã€Cï¼ˆå·²çŸ¥ç†æƒ³ä½ç½®å’Œå®é™…ä½ç½®ï¼‰
2. åˆ©ç”¨Måˆ°Aã€Bã€Cçš„è§’åº¦çº¦æŸ
3. é€šè¿‡å‡ ä½•æ–¹ç¨‹æ±‚è§£Mçš„æœ€ä¼˜ä½ç½®
```

### 2. æ•°å­¦æ¨¡å‹
```python
# è§’åº¦çº¦æŸ
Î±_A = âˆ AMO  # Måˆ°Aå’ŒåŸç‚¹çš„å¤¹è§’
Î±_B = âˆ BMO  # Måˆ°Bå’ŒåŸç‚¹çš„å¤¹è§’  
Î±_C = âˆ CMO  # Måˆ°Cå’ŒåŸç‚¹çš„å¤¹è§’

# ç›´çº¿æ–¹ç¨‹ï¼ˆè¿‡Må’Œå‚è€ƒç‚¹ï¼‰
L_A: aâ‚x + bâ‚y + câ‚ = 0
L_B: aâ‚‚x + bâ‚‚y + câ‚‚ = 0
L_C: aâ‚ƒx + bâ‚ƒy + câ‚ƒ = 0

# ä¼˜åŒ–ç›®æ ‡
minimize: Î£|âˆ (X,O,Páµ¢) - Î±áµ¢|
```

### 3. å…³é”®ç®—æ³•æ­¥éª¤
```python
def single_iteration():
    for each_combination in valid_combinations:
        for each_plane in planes_to_adjust:
            # 1. æ„å»ºå‡ ä½•çº¦æŸ
            constraints = build_angle_constraints()
            
            # 2. æ±‚è§£å€™é€‰ä½ç½®
            candidates = solve_line_intersections()
            
            # 3. é€‰æ‹©æœ€ä¼˜å€™é€‰
            best_pos = minimize_angle_error(candidates)
            
            # 4. è®¡ç®—ç§»åŠ¨å‘é‡
            movement = calculate_movement(best_pos)
            
            # 5. æ›´æ–°ä½ç½®ï¼ˆéå‚è€ƒé£æœºï¼‰
            if not_reference_plane:
                update_position(movement)
        
        # è®¡ç®—æ€»è¯¯å·®
        total_error = sum(position_errors)
    
    # é€‰æ‹©æœ€ä¼˜ç»„åˆ
    return best_combination_with_min_error
```

## ğŸ“Š å®éªŒç»“æœ

### è¿è¡Œæ•ˆæœ
```
=== é”¥å½¢ç¼–é˜Ÿä¼˜åŒ–ç®—æ³• ===
æœ‰æ•ˆç»„åˆæ•°é‡: 352
è¿­ä»£ 1/50: æœ€ä¼˜ç»„åˆ: [5 9 12], æ€»è¯¯å·®: 12.8659
è¿­ä»£ 2/50: æœ€ä¼˜ç»„åˆ: [1 11 14], æ€»è¯¯å·®: 9.5970
...
è¿­ä»£ 19/50: æœ€ä¼˜ç»„åˆ: [8 9 15], æ€»è¯¯å·®: 0.0000
...
æœ€ç»ˆç»“æœ: æœ€ä¼˜ç»„åˆ: [5 8 15], æ€»è¯¯å·®: 0.0000
```

### æ”¶æ•›ç‰¹æ€§
- **å¿«é€Ÿæ”¶æ•›**: é€šå¸¸åœ¨20è½®è¿­ä»£å†…è¾¾åˆ°é«˜ç²¾åº¦
- **å…¨å±€æœ€ä¼˜**: é€šè¿‡å…¨æœç´¢ç¡®ä¿æ‰¾åˆ°æœ€ä¼˜è§£
- **æ•°å€¼ç¨³å®š**: è¯¯å·®å¯é™è‡³1e-6çº§åˆ«

## ğŸ”¬ å…³é”®æŠ€æœ¯ç‚¹

### 1. ç»„åˆç­›é€‰ç­–ç•¥
```python
# æ’é™¤å·²çŸ¥ä¸å¯è¡Œç»„åˆ
no_need_combinations = [
    [1,2,3], [1,4,6], [1,7,10], [1,11,15],
    [1,12,14], [1,8,9], [5,2,3], [5,4,6],
    [5,7,10], [5,11,15], [5,12,14], [5,8,9]
]

# ä»352ä¸ªæœ‰æ•ˆç»„åˆä¸­é€‰æ‹©æœ€ä¼˜
valid_combinations = filter_combinations(all_combinations, no_need_combinations)
```

### 2. å‡ ä½•æ±‚è§£æ–¹æ³•
```python
def solve_optimal_position(M, A, B, C, std_A, std_B, std_C):
    # æ„å»ºè¿‡Må’Œå‚è€ƒç‚¹çš„ç›´çº¿
    line_MA = solve_line_params(M, A)
    line_MB = solve_line_params(M, B) 
    line_MC = solve_line_params(M, C)
    
    # è®¡ç®—ç›´çº¿ä¸ç†æƒ³ä½ç½®çš„äº¤ç‚¹
    intersect_AB = solve_intersect(line_MA, line_MB)
    intersect_BC = solve_intersect(line_MB, line_MC)
    intersect_AC = solve_intersect(line_MA, line_MC)
    
    # è¯„ä¼°å€™é€‰ç‚¹
    candidates = [intersect_AB, intersect_BC, intersect_AC, centroid]
    best_candidate = min(candidates, key=lambda p: angle_error(p))
    
    return best_candidate
```

### 3. ä½ç½®æ›´æ–°ç­–ç•¥
```python
def update_position(plane_id, optimal_pos, target_pos, current_pos, lambda_factor):
    # è®¡ç®—ç§»åŠ¨å‘é‡
    movement_vector = target_pos - optimal_pos
    controlled_movement = lambda_factor * movement_vector
    
    # éå‚è€ƒé£æœºæ‰ç§»åŠ¨
    if plane_id not in reference_combination:
        new_position = current_pos + controlled_movement
        return new_position
    else:
        return current_pos  # å‚è€ƒé£æœºä¿æŒä¸åŠ¨
```

## ğŸš€ ç®—æ³•ä¼˜åŠ¿

### 1. **å…¨å±€ä¼˜åŒ–èƒ½åŠ›**
- æ¯è½®è¿­ä»£è¯„ä¼°æ‰€æœ‰å¯èƒ½çš„ä¸‰æœºç»„åˆ
- é¿å…é™·å…¥å±€éƒ¨æœ€ä¼˜è§£

### 2. **å‡ ä½•çº¦æŸä¸¥æ ¼**
- åŸºäºä¸¥æ ¼çš„å‡ ä½•å…³ç³»è¿›è¡Œæ±‚è§£
- ä¿è¯è§£çš„ç‰©ç†æ„ä¹‰å’Œåˆç†æ€§

### 3. **è‡ªé€‚åº”è°ƒæ•´**
- æ ¹æ®å½“å‰è¯¯å·®çŠ¶æ€åŠ¨æ€é€‰æ‹©æœ€ä¼˜ç»„åˆ
- ç§»åŠ¨æ­¥é•¿å¯æ§ï¼Œä¿è¯æ”¶æ•›ç¨³å®šæ€§

### 4. **é²æ£’æ€§å¼º**
- å¯¹åˆå§‹ä½ç½®åå·®æœ‰è‰¯å¥½çš„é€‚åº”æ€§
- å¤šå€™é€‰ç‚¹ç­–ç•¥æé«˜è§£çš„ç¨³å®šæ€§

## ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡

### è®¡ç®—å¤æ‚åº¦
- **ç»„åˆæœç´¢**: O(C(14,3)) = O(364) per iteration
- **ä½ç½®ä¼˜åŒ–**: O(14) planes per combination  
- **æ€»å¤æ‚åº¦**: O(364 Ã— 14 Ã— iterations) â‰ˆ O(255,000) for 50 iterations

### æ”¶æ•›æ€§èƒ½
- **æ”¶æ•›é€Ÿåº¦**: é€šå¸¸15-20è½®è¿­ä»£
- **æœ€ç»ˆç²¾åº¦**: è¯¯å·®å¯è¾¾1e-6çº§åˆ«
- **ç¨³å®šæ€§**: å¤šæ¬¡è¿è¡Œç»“æœä¸€è‡´

## ğŸ› ï¸ ä½¿ç”¨æ–¹æ³•

### åŸºæœ¬ä½¿ç”¨
```python
# å¯¼å…¥ä¼˜åŒ–å™¨
from q4_cone_formation_python import ConeFormationOptimizer

# åˆ›å»ºå®ä¾‹
optimizer = ConeFormationOptimizer()

# æ‰§è¡Œä¼˜åŒ–
results = optimizer.optimize(noise_ratio=0.1)

# å¯è§†åŒ–ç»“æœ
optimizer.plot_positions(results['positions'][-1])
optimizer.plot_error_convergence(results['errors'])
```

### å‚æ•°è°ƒæ•´
```python
optimizer.max_iter = 30        # æœ€å¤§è¿­ä»£æ¬¡æ•°
optimizer.lmd = [0.8, 0.8]     # ç§»åŠ¨æ­¥é•¿æ§åˆ¶
optimizer.sigma = 45           # é—´è·å‚æ•°
```

## ğŸ”® æ‰©å±•å¯èƒ½æ€§

### 1. **ä¸‰ç»´æ‰©å±•**
- æ‰©å±•åˆ°ä¸‰ç»´ç©ºé—´çš„é”¥å½¢ç¼–é˜Ÿ
- å¢åŠ é«˜åº¦ç»´åº¦çš„çº¦æŸå’Œä¼˜åŒ–

### 2. **åŠ¨æ€ç¼–é˜Ÿ**
- æ”¯æŒç¼–é˜Ÿåœ¨è¿åŠ¨è¿‡ç¨‹ä¸­çš„å®æ—¶è°ƒæ•´
- è€ƒè™‘æ—¶é—´åºåˆ—çš„ä½ç½®ä¼˜åŒ–

### 3. **å¤šç›®æ ‡ä¼˜åŒ–**
- åŒæ—¶ä¼˜åŒ–ä½ç½®ç²¾åº¦å’Œèƒ½è€—
- å¹³è¡¡ç¼–é˜Ÿç´§å‡‘æ€§å’Œå®‰å…¨è·ç¦»

### 4. **åˆ†å¸ƒå¼å®ç°**
- å°†ç®—æ³•éƒ¨ç½²åˆ°å¤šä¸ªè®¡ç®—èŠ‚ç‚¹
- å®ç°å¤§è§„æ¨¡ç¼–é˜Ÿçš„å®æ—¶ä¼˜åŒ–

## ğŸ“š ç›¸å…³æ–‡ä»¶è¯´æ˜

### å®Œæ•´ç‰ˆæœ¬ (`q4_cone_formation_python.py`)
- åŒ…å«å®Œæ•´çš„ä¼˜åŒ–ç®—æ³•å®ç°
- æä¾›è¯¦ç»†çš„æ—¥å¿—è¾“å‡ºå’Œå¯è§†åŒ–åŠŸèƒ½
- é€‚åˆå®é™…åº”ç”¨å’Œæ·±å…¥ç ”ç©¶

### ç®€åŒ–ç‰ˆæœ¬ (`q4_simplified_algorithm.py`)
- çªå‡ºæ ¸å¿ƒç®—æ³•é€»è¾‘ï¼Œä»£ç ç»“æ„æ¸…æ™°
- æ·»åŠ è¯¦ç»†æ³¨é‡Šï¼Œé€‚åˆå­¦ä¹ å’Œç†è§£
- å¯ä½œä¸ºæ•™å­¦æ¼”ç¤ºä½¿ç”¨

### è¾…åŠ©å‡½æ•° (`q4_helper_functions.py`)
- åŒ…å«æ‰€æœ‰åº•å±‚æ•°å­¦è®¡ç®—å‡½æ•°
- å¯¹åº”MATLABåŸå§‹ä»£ç çš„å„ä¸ªå‡½æ•°
- å¯ç‹¬ç«‹ä½¿ç”¨å’Œæµ‹è¯•

è¿™ä¸ªè§£å†³æ–¹æ¡ˆå°†å¤æ‚çš„ç¼–é˜Ÿä¼˜åŒ–é—®é¢˜è½¬åŒ–ä¸ºå¯æ±‚è§£çš„å‡ ä½•çº¦æŸä¼˜åŒ–é—®é¢˜ï¼Œé€šè¿‡ç³»ç»Ÿæ€§çš„æœç´¢å’Œä¼˜åŒ–ç­–ç•¥ï¼Œå®ç°äº†é«˜ç²¾åº¦ã€é«˜æ•ˆç‡çš„é”¥å½¢ç¼–é˜Ÿæ§åˆ¶ç®—æ³•ã€‚
